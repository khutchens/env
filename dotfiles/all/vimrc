" don't set term type, just let vim get it from $TERM, which is more portable.
"set term=rxvt-color 

colorscheme kyle

let loaded_matchparen = 1

" general behavior
set backspace=2     " make backspace work like most other apps
set number          " turn line numbers on
set hlsearch        " highlight search results so they're easier to find
set laststatus=2    " always show status line
set noerrorbells    " annoying noises
set novisualbell    " annoying flashes
set ruler           " show row/column and % info in status bar
set tabstop=4       " tab are 4 spaces wide. this is for cases without expanded tabs
syntax enable       " enable syntax highlighting by default
set wildmode=longest,list
set scrolloff=10    " scroll before cursor reaches edge of screen
set autowrite       " automatically write changes to file

" set indent behavior
set expandtab
set shiftwidth=4
set softtabstop=4

" makes launch faster, and leaves vim buffer onscreen after exit
set t_ti= t_te=

" highlight modes for unusual file types
au BufNewFile,BufRead makefile  setlocal noexpandtab shiftwidth=4 softtabstop=4
au BufNewFile,BufRead Makefile  setlocal noexpandtab shiftwidth=4 softtabstop=4
au BufNewFile,BufRead *.mk  setlocal noexpandtab shiftwidth=4 softtabstop=4

" leader, obviously
let mapleader=","

" make window/frame resizing and navigation easier
nnoremap <Tab> :bnext<CR>
nnoremap <S-Tab> :bprevious<CR>
nnoremap <leader>q :bdelete<CR>
set splitbelow

" use <space> to clear hilight after searching
nnoremap <silent> <Space> :<C-U>noh<CR>:cclose<CR>

" python highlighting options
let python_highlight_builtins           = 1
let python_highlight_builtin_objs       = 1
let python_highlight_builtin_funcs      = 1
let python_highlight_exceptions         = 1
let python_highlight_string_formatting  = 1
let python_highlight_indent_errors      = 1
let python_highlight_space_errors       = 1

" replace grep with ag
if executable('ag')
    " Use ag over grep
    set grepprg=ag\ --nogroup\ --nocolor\ --ignore\ build
endif

" fzf
nnoremap <silent> <leader>fe :call fzf#run({'sink': 'edit'})<CR>
nnoremap <silent> <leader>ft :call FzfTagsfile()<CR>
nnoremap <silent> <leader>ff :call FzfTagSearch(expand('%'), 'f', 1)<CR>
nnoremap <silent> <leader>fF :call FzfTagSearch('', 'f', 1)<CR>
nnoremap <silent> <leader>fv :call FzfTagSearch(expand('%'), '', 1)<CR>
nnoremap <silent> <leader>fV :call FzfTagSearch('', '', 1)<CR>
nnoremap <silent> <leader>fy :call FzfTagInsert('', '')<CR>
nnoremap <silent> <leader>fb :call FzfBuffers('buffer', 0)<CR>
nnoremap <silent> <leader>fq :call FzfBuffers('bdelete', 1)<CR>
nnoremap <silent> <leader>fh :call FzfHelp()<CR>
nnoremap <silent> <leader>ss :call ClangFormat()<CR>

function ClangFormat()
    let l:pos = getpos('.')
    execute('% !clang-format -style=file')
    call setpos('.', l:pos)
endfunction

function FzfTagsfile()
    " select tag files
    let l:files = []
    for l:file in fzf#run({'options': '--query=tags'})
        " shorten file names as much as possible while removing leading ./ since it confuses vim
        let l:files += [fnamemodify(l:file, ':~:.')]
    endfor

    execute('set tags=' . join(l:files, ","))
    execute('set tags notagrelative')
endfunction

function FzfTagInternal(file, kind)
    let l:tags = taglist('.')

    " filter out unwanted files and types
    if a:kind != '' | call filter(l:tags, 'v:val.kind == a:kind') | endif
    if a:file != '' | call filter(l:tags, 'v:val.filename == a:file') | endif

    " fzf just wants names
    call map(l:tags, 'v:val.name')

    " select a tag
    silent! let l:tag = fzf#run({'source': l:tags, 'options': '--no-multi'})
    if len(l:tag) != 1
        return -1
    endif

    return taglist(l:tag[0])[0]
endfunction

function FzfTagExternal(file, kind)
    " This is an alternate tag selector that builds a taglist directly from the
    " tag files rather than using vim's builtin taglist(). This isn't actually
    " significantly faster, but it allows fzf to start displaying tags as they
    " come in over the pipe rather than waiting until the full tag list is built,
    " which feels nicer.

    let l:tagfiles = tagfiles()
    if len(l:tagfiles) == 0
        echo "No tag file selected!"
        return -1
    endif

    let l:source_command = []

    call add(l:source_command, 'grep -v ! ' . join(l:tagfiles, ' '))
    if a:kind != '' | call add(l:source_command, 'awk -F \t ''{if ("' . a:kind . '" == $4) { print } }''') | endif
    if a:file != '' | call add(l:source_command, 'awk -F \t ''{if ("' . a:file . '" ~ $2) { print } }''') | endif
    call add(l:source_command, 'awk -F \t ''{print $1}''')

    let l:source_command_string = join(l:source_command, ' | ')
    silent! let l:tag = fzf#run({'source': l:source_command_string, 'options': '--no-multi'})
    if len(l:tag) != 1
        return -1
    endif

    return taglist(l:tag[0])[0]
endfunction

function FzfTagSearch(file, kind, external)
    if a:external
        let l:tag = FzfTagExternal(a:file, a:kind)
    else
        let l:tag = FzfTagInternal(a:file, a:kind)
    endif
    if type(l:tag) != v:t_dict
        return -1
    endif
    
    " shorten name for readability
    let l:fname = fnamemodify(l:tag.filename, ':.')

    " find tag's buffer, creating a new one if necessary
    let l:buf = bufnr(l:fname)
    if l:buf < 0
        execute('edit ' . l:fname)
    else
        execute('buffer ' . l:fname)
    endif

    " go to tag
    let l:cmd = substitute(l:tag.cmd, '\([*\[\]]\)', '\\\1', 'g')
    execute(l:cmd)
endfunction

function FzfTagInsert(file, kind)
    let l:tag = FzfTagExternal(a:file, a:kind)
    if type(l:tag) != v:t_dict
        return -1
    endif

    let @" = l:tag.name
endfunction

function FzfBuffers(command, multi)
    let l:bufs = range(1, bufnr('$'))
    call filter(l:bufs, 'buflisted(v:val)')
    call map(l:bufs, 'bufname(v:val)')

    if a:multi
        silent! let l:bufs_selected = fzf#run({'source': l:bufs})
    else
        silent! let l:bufs_selected = fzf#run({'source': l:bufs, 'options': '--no-multi'})
    endif

    for l:buf in l:bufs_selected
        execute(a:command . ' ' . l:buf)
    endfor
endfunction

function FzfHelp()
    let l:bufs = getbufinfo()
    call filter(l:bufs, '(len(v:val.windows) > 0) && has_key(v:val.variables, "current_syntax") && (v:val.variables.current_syntax == "help")')
    if len(l:bufs) > 0
        let l:win = l:bufs[0].windows[0]
        call win_gotoid(l:win)
    else
        execute('help')
    endif
    call FzfTagSearch('', '', 0)
endfunction

